# 数据结构

- [动态数组](#动态数组)
- [链表](#链表)
- [栈](#栈)
- [队列](#队列)
- [二叉搜索树](#二叉搜索树)
- [平衡二叉搜索树](#平衡二叉搜索树)
- [红黑树](#红黑树)
- [集合和映射](#集合和映射)
- [哈希表](#哈希表)

在学习数据结构之前，我一直不知道语言提供的数组，set，map 类型的底层是怎么实现的，也没有这个概念。为什么数组还分为长度不可变数组和动态数组。为什么 set，map 这些类型存取海量的元素速度这么快。本例中的例子都是 `go` 的。

## 复杂度

复杂度包括时间复杂度和空间复杂度。`时间复杂度`表示执行一段代码所需的时间，`空间复杂度`表示执行一段代码用到的内存空间大小。

## 动态数组

数据结构中最简单的就是动态数组了。

我们知道，数组之间的元素，他们的内存地址应该是连续的，也就是说申请内存的时候，就要事先指定申请多大的内存。比如下面的代码：

```
var arr = [10]int{}
```

在 `golang` 中，平时我们使用的一般都是 `slice` ，也就是动态数组。动态数组的长度是不固定的，你往里面添加多少元素都可以。

那么动态数组是怎么办到的呢？

实际上，动态数组的原理类似于给数组封装了一层，自己内部实现插入和删除元素的逻辑。

插入元素的时候，如果是插入到某个中间位置，则会让这个位置后面的元素全部往后挪，如果发现当时申请的数组元素个数不够用了，这时就需要`扩容`，申请一段更大的内存空间，然后把老的内存空间上面的元素全部复制过去，然后使用新申请的内存。

删除元素的时候，如果删除的是某个中间的元素，那么会把那个元素后面的元素全都往前挪。而且删除元素可能会发生`缩容`，在发现数组的空闲容量太多的情况，这时候需要申请一段小一点的内存空间，然后把所有数据复制过去。

这些操作对外部都是不可见的，实际使用的人不用管什么扩容和缩容的操作。

动态数组的各个元素在内存中都是连续的，这就表示获取某个元素的时候可以直接定位到那个元素的内存地址，时间复杂度是 `O(1)` ，但是删除原属和添加元素的时候，会让该元素后面的元素全部往前或往后挪，所以删除和插入元素的时间复杂度是O(n)

## 链表

链表和动态数组类似，在外界看来可能都是一个数组，但是链表的内部实现和动态数组不太一样。

链表内部的元素内存地址是不连续的，链表会有一个 first 指针指向链表的第一个元素。每个元素称为一个节点（node），每个节点内部会有一个 next 指针指向下一个节点（如果节点内部还有一个 prev 指针指向前一个节点，那么就是双向链表，第一个节点的 prev 指针为 nil，最后一个节点的 next 指针也为 nil）。比如说我想访问链表中的第五个元素，就要通过 first 指针找到第一个元素，通过第一个元素的 next 指针找到第二个元素，以此类推，直到找到第5个。

链表相对于动态数组，他的插入元素和删除元素的速度非常快，只需要找到插入位置的前一个节点，改变他的 next 指针指向就可以了。复杂度是 `O(1)` 。

但是链表的查找元素就比较慢了，链表不能直接定位到某个元素的内存地址，而是要先找到第一个，再找第二个元素...依次找下去，所以查找元素的时间复杂度是 `O(n)` 。

`golang` 的官方标准库中也有链表，是一个双向链表，只是我平时很少用，给个例子：

```
import (
	"container/list"
)

func main() {
  list := list.New()
  for i := 0; i <= 10; i++ {
    list.PushBack(i)
  }
  // 遍历链表
  for p := list.Front(); p != list.Back(); p = p.Next() {
    fmt.Println("Number", p.Value)
  }
}
```

如果需要频繁的插入和删除元素应该选用链表，如果频繁的获取元素应该用动态数组。


## 栈

这里的`栈`是一种数据结构，和内存中的栈空间完全不是一个东西。

栈这种数据结构的特点是`后进先出`，只能在一端进行操作，最后添加进来的元素最先出去，添加元素称为入栈（push），获取元素称为出栈（pop）。

栈这种数据结构其实可以用上面的动态数组或链表来实现都可以。


## 队列

`队列`只能在头尾两端进行操作。

只能从对尾添加元素，只能从对头移除元素。往队尾添加元素叫做入队(EnQueue)，从队头移除元素叫做出队(DeQueue)，

队列优先使用双向链表来实现，因为队列主要是在对头和对尾进行操作。


## 二叉搜索树

想象一个需求，在n个整数中如何查找某个整数是否存在。

这时如果利用我们上面说的动态数组，链表，栈，队列这些数据结构都是不太好实现的，如果用动态数组的话，需要遍历数组中的所有元素，一个个来比较。链表也是一样。时间复杂度都是 `O(n)` 。

那么有没有更好的方案呢？

答案是有的，就是使用二叉搜索树。二叉搜索树的查找，添加，删除的时间复杂度都是 `O(logn)` 。

`二叉搜索树`是一种树形的数据结构（动态数组，链表都是线形的），二叉搜索树中的元素都是可比较的。顾名思义是两个叉的，每个节点都有 `left` 和 `right` 两个指针，比她小的就存左边，大的就存右边。

`二叉搜索树` 的节点的结构是：

```
type treeNode struct {
  element interface{}
  left *treeNode
  right *treeNode
}
```

添加一个元素的时候，会先和根节点比较，比根节点小，就往左走，反之往右走，直到比较的那个节点没有子节点了，就添加在那个节点的左边或右边。搜索一个元素的时候，也是和根节点比较，比他小就往左边搜索，比他大就往右边搜索。也就是说，添加，删除，搜索的时候，每经过一次比较，就可以排除一般的元素，所以性能是非常好的。


## 平衡二叉搜索树

二叉搜索树在一些特殊情况下会`退化成链表`，这样的话再做添加搜索删除的操作，时间复杂度就很高了。所以我们需要一种机制能防止二叉搜索树退化成链表。

这种机制叫做`平衡`。平衡二叉搜索树也叫做`AVL树` 。

平衡二叉搜索树使用`平衡因子`（balance factor）来实现平衡。让树中所有节点的`左右子树的高度差的绝对值不超过1`。如果超过1了，就说明这个节点不平衡了，需要做一些操作来使这个节点重新恢复平衡。

这里涉及到两个概念，`节点的高度`和`树的高度`。节点的高度等于当前节点到最远叶子节点的路径上饿节点总数。树的高度取所有节点高度中的最大值。

既然上面说左右子树的高度差超过1了就不平衡了，那么怎么恢复平衡呢？

就是通过旋转。旋转分为`左旋转`和`右旋转`。旋转是什么意思呢？

我们直接来看动画，图片中节点的左上角有个数字，表示那个节点的高度，并不是平衡因子。在加入7这个节点后，节点5的左子树高度是0，右子树高度是2，相差为2，就是平衡因子为2，表示5这个节点不平衡了，需要对5这个失衡的节点进行左旋转。

<div align="center"><img width="300px" src="./2020.05.12/leftrotate.gif"/></div>

对失衡的节点进行旋转很好理解，但是图中这种情况为什么是左旋转？这就要看比较高的子树是在失衡节点的哪一边，图中是失衡节点5的右子树太高了，所以要进行左旋转。同理，如果是左子树太高了，就进行右旋转。

以下是右旋转的例子：

<div align="center"><img width="300px" src="./2020.05.12/rightrotate.gif"/></div>


通过旋转那个失衡节点，使那个失衡的节点往下走，让他比较高的那个子树往上走，然后这个失衡的节点成为子节点的子节点，来达到平衡。

## 红黑树

虽然AVL树很美好，但有一些缺陷，就是AVL树在删除节点的时候，最坏的情况是会发生 `logn` 次的旋转调整（一直失衡到根节点）。所以接下来引入红黑树，删除元素的只要 `O(1)` 次旋转就可以了。

红黑树也是一种自平衡树，但是平衡的方法和AVL树不一样，红黑树只遵循5条性质，只要遵循了这5条性质，这颗红黑树自然就平衡了。红黑树上的节点不是红色就是黑色，这个颜色不代表任何东西，只是单纯的为了满足他的性质。这5条性质是：

1. 红黑树中的节点不是红色就是黑色。
2. 根节点必须是黑色。
3. 叶子节点都是黑色。
4. 红色节点的子节点都是黑色。
5. 从任意节点到叶子节点的所有路径都包含相同数目的黑色节点。

只要一棵树满足了这5个条件，这棵树就很神奇的平衡了。注意：红黑树不是靠平衡因子来平衡的，所以在红黑树中没有平衡因子这个概念。

关于第三条性质需要讲一下，这说的叶子节点并不是真实的叶子节点，而是假想出来的，比如下面这张图，假想了黑色的 null 叶子节点，而实际上真实的叶子节点可以是红色的。（对于第三条性质比较疑惑，既然100%能满足为什么还要有这条性质）

<div align="center"><img width="300px" src="./2020.05.12/rbtree01.jpg"/></div>

对于为什么满足上面5点就能平衡，这个就不讲了。简单来说红黑树和4阶B树是等价的，可以相互转换，只要把红色节点上移一层，和上层的黑色节点合并为一个超级节点，其实就是4阶B树。红黑树添加删除元素也是和4阶B树是一样的。

我们来看以下红黑树的添加过程，确实是满足上面5点的。

<div align="center"><img width="500px" src="./2020.05.12/rbtree02.gif"/></div>

接下来我都是把红色节点和他们的黑色父节点看作是一个超级节点。

对于红黑树，新添加的节点必然是添加到树的最后一层的，新添加的节点只会遇到四种情况。

<div align="center"><img width="500px" src="./2020.05.12/rbtree03.jpg"/></div>

第一种情况，新添加的节点添加到了 【05，10，15】 这个超级节点上，比如我们新添加了 01 这个节点。由于四阶B树的特性是超级节点最多只能有3个元素，所以该节点会发生上溢现象，取中间的一个元素 05 上溢到上一层，图中这个例子中 05 这个节点上溢到上一层后，上一层的超级节点数量已经是3个了【25，100，170】，所以又回发生上溢现象，最终导致树的高度增加。

第二种情况，比如我们新增了 29 这个节点，很明显是添加到 30 的左边，而且新添加的节点 29 也是红色的（因为我们默认新添加的节点都是红色），这个时候会导致 29 和 30 两个连续红色的节点，与性质4不符。所以我们修复性质4的方法就是右旋转 50 这个节点， 50 节点下来，30 节点上去，让 30 这个节点作为子树的根节点，让 30 变为黑色， 50 变为红色，这样就可以了。

如果我们新增的是 31 节点，那么会添加在 30 节点的右边，和上面的情况类似，也是需要修复性质4，但是是让 31 这个节点作为超级节点的根节点，所以这种情况需要做两次旋转，先对 30 做左旋转，再对 50 做右旋转，在让根节点变黑色，两边变红色。

如果我们新增的是 51 ，那么很简单，只要添加到 50 节点的右边就可以了，什么都不用做，因为红黑树的性质并没有被破坏。

第三种情况，和第二种情况类似，就不多说了。

第四种情况，最简单的一种情况，不管添加到 175 的左边或右边，红黑树的性质都不会被破坏。

红黑树的删除比较复杂，也分为四种情况，我在下图中给叶子节点标了号。

<div align="center"><img width="500px" src="./2020.05.12/rbtree04.jpg"/></div>

删除只可能会删除最后一层的元素，这里的最后一层指的是红色节点和他们的父节点组成的超级节点看作是一层。

哎。有人会说了，如果我删除的是 25 怎么办？在二叉树中删除度为2的节点，实际上是删除那个节点的`前驱`或者`后继节点`，所以实际上删的还是最后一层的节点。

好了，既然我们确定了删除只有8中情况了，那么接下来看。

第一种情况：如果我删除的是 1，2，3，6 这几个红色节点，直接删掉就行了，因为不会破坏红黑树的性质。

第二种情况：删除的是 4 和 5 两个节点，那就让他们的红色子节点变为黑色代替他们就好了。

第三种情况最复杂，如果把 7 号的节点删了，会发生`下溢`现象。这时7好那个位置的节点为空了，需要向父节点拿一个元素，我这里说的节点都是超级节点。如下图，红框框起来的都是超级节点。

<div align="center"><img width="500px" src="./2020.05.12/rbtree05.jpg"/></div>

如果把 175 这个节点给删了，那么下层最右边的超级节点就空了，这是不行的，他会去父节点获取一个元素下来，这里会把 170 这个节点拉下来，但是拉下来后，上层的超级节点就少了一个元素了，他们会把空掉的超级节点的兄弟节点（图中是【150,160】这个节点）拿一个元素上去。

兄弟节点这时又有多种情况，兄弟节点有多个元素，需要借一个元素给父节点。会借最大或最小的元素上去，取决于那个空的超级节点是兄弟节点的哪一边。

还有一直情况是兄弟节点本身也就只有一个元素，没有东西可借了，这时候会拉父节点一个元素下来和两个兄弟节点一起合并为一个超级节点。

而且以上的删除操作可能会导致父节点上溢，这时只需要把父节点当作是要删除的节点递归调用删除节点的函数就可以了。


## 集合和映射

集合和映射对应与 golang 里面的 map 。 golang 没有直接的 set 类型，因为 map 这种类型可以当 set 用。只要把 map 的 value 设置为 true 就可以了。那么 map 这种数据结构底层是怎么实现的呢？

就是上面说的红黑树。实际上用AVL树也是可以的，但是因为红黑树要优于AVL树，所以我们接下来都是用红黑树。

只要我们这样定义树中的节点：

```
type node struct {
  key interface{}
  value interface{}
  parent *node
  left *node
  right *node
  color bool
}
```

树中的每一个节点都是存有 key， value 的，而且我们红黑树中的比较是根据 key 来比较往左还是往右的，这样不就可以了吗。

但外界传来一个key时，我们拿 key 来根红黑树中的节点一个个比较，最终定位到 key 相等的那个节点，最后把 value 值返回出去就可以了。

既然是这样的话，那么我们的 map 这个数据结构的查询，添加，删除的时间复杂度是 `O(logn)` 。

实际上 golang 的 map 内部是用哈希表实现的，哈希表是一种空间换时间的一种数据结构。查询，添加，删除的时间复杂度是 `O(1)` 。

## 哈希表

哈希表也叫做`散列表`（hash 有剁碎的意思）。哈希表有一个很重要的特征是哈希表里的元素不需要具备比较性。像我们上面说的红黑树，AVL树，都是需要元素具备可比性，用红黑树实现的map也是一样，map里的元素需要具备可比性。这是一个很重要的区别。

哈希表是一种结合`动态数组`和`红黑树`的结构。为了达到哈希表的查询，添加，删除时间复杂度是 `O(1)` 级别的，就需要用到数组，因为数组访问下标的元素时间复杂度都是 `O(1)` 的。但是如果用纯数组的话，会极大的浪费内存空间，所以我们要结合红黑树。

原理是这样的，比如下面这句代码：

```
m := make(map[string]string, 0)
m["key"] = 22
```

哈希表内部维护一个数组，当外部传进来一个 key 时，我们先对这个 key 做 hash 运算，产生一个整数，这个整数经过运算映射到数组中的一个索引位置，再把 22 放到数组的这个索引位置上。数组中每个索引的位置也成为`桶`。

当然，哈希运算的算法的一个要求就是计算的哈希码要尽可能的均匀分布在数组的索引中。

需要注意的是，经过哈希运算获取的 hash 码并不是唯一的。两个完全不同的对象有可能计算出相同的哈希码，这就产生了一个`哈希冲突`的问题。

因为存在哈希冲突，所以有可能两个完全不同的key索引到了数组的同一个位置，所以哈希表内部的数组的每个位置不能只放一个元素。实际上，数组中的每个索引都对应着一颗红黑树。所以拿到哈希码定位到数组的某个元素后，这个元素是红黑树的根节点，需要一步步比较下去，直到 key 相同为止。

那么既然用户设置的 key 肯定是没有顺序的，可能是整数，浮点数，字符串，也可能是自定义对象，但是红黑树里的元素是要有可比性的，这个怎么办呢？

我们可以比较哈希值，上面说到哈希值是整数，这不正好可以比么。

那如果哈希值一样呢？

虽然概率比较低，但是还是有可能发生的，当哈希值一样的时候，这时候其实是不好比的，可能每种语言的实现都不一样，有些语言会比较key的内存地址大小，有些会先看元素本身有没有可比性，或者有没有实现可比较的一些方法。但是其实你直接写死让元素往左或往右也是可以的。

正因为有 key 无法比较的时候，所以我们在查找key这时候，定位到具体的桶之后，需要遍历这个桶的整棵红黑树。




