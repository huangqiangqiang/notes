# 数据结构

在学习数据结构之前，我一直不知道语言提供的数组，set，map 类型的底层是怎么实现的，也没有这个概念。为什么数组还分为长度不可变数组和动态数组。为什么 set，map 这些类型存取海量的元素速度这么快。本例中的例子都是 `go` 的。

### 复杂度

复杂度包括时间复杂度和空间复杂度。`时间复杂度`表示执行一段代码所需的时间，`空间复杂度`表示执行一段代码用到的内存空间大小。

### 动态数组

数据结构中最简单的就是动态数组了。

我们知道，数组之间的元素，他们的内存地址应该是连续的，也就是说申请内存的时候，就要事先指定申请多大的内存。比如下面的代码：

```
var arr = [10]int{}
```

在 `golang` 中，平时我们使用的一般都是 `slice` ，也就是动态数组。动态数组的长度是不固定的，你往里面添加多少元素都可以。

那么动态数组是怎么办到的呢？

实际上，动态数组的原理类似于给数组封装了一层，自己内部实现插入和删除元素的逻辑。

插入元素的时候，如果是插入到某个中间位置，则会让这个位置后面的元素全部往后挪，如果发现当时申请的数组元素个数不够用了，这时就需要`扩容`，申请一段更大的内存空间，然后把老的内存空间上面的元素全部复制过去，然后使用新申请的内存。

删除元素的时候，如果删除的是某个中间的元素，那么会把那个元素后面的元素全都往前挪。而且删除元素可能会发生`缩容`，在发现数组的空闲容量太多的情况，这时候需要申请一段小一点的内存空间，然后把所有数据复制过去。

这些操作对外部都是不可见的，实际使用的人不用管什么扩容和缩容的操作。

动态数组的各个元素在内存中都是连续的，这就表示获取某个元素的时候可以直接定位到那个元素的内存地址，时间复杂度是 `O(1)` ，但是删除原属和添加元素的时候，会让该元素后面的元素全部往前或往后挪，所以删除和插入元素的时间复杂度是O(n)

### 链表

链表和动态数组类似，在外界看来可能都是一个数组，但是链表的内部实现和动态数组不太一样。

链表内部的元素内存地址是不连续的，链表会有一个 first 指针指向链表的第一个元素。每个元素称为一个节点（node），每个节点内部会有一个 next 指针指向下一个节点（如果节点内部还有一个 prev 指针指向前一个节点，那么就是双向链表，第一个节点的 prev 指针为 nil，最后一个节点的 next 指针也为 nil）。比如说我想访问链表中的第五个元素，就要通过 first 指针找到第一个元素，通过第一个元素的 next 指针找到第二个元素，以此类推，直到找到第5个。

链表相对于动态数组，他的插入元素和删除元素的速度非常快，只需要找到插入位置的前一个节点，改变他的 next 指针指向就可以了。复杂度是 `O(1)` 。

但是链表的查找元素就比较慢了，链表不能直接定位到某个元素的内存地址，而是要先找到第一个，再找第二个元素...依次找下去，所以查找元素的时间复杂度是 `O(n)` 。

`golang` 的官方标准库中也有链表，是一个双向链表，只是我平时很少用，给个例子：

```
import (
	"container/list"
)

func main() {
  list := list.New()
  for i := 0; i <= 10; i++ {
    list.PushBack(i)
  }
  // 遍历链表
  for p := list.Front(); p != list.Back(); p = p.Next() {
    fmt.Println("Number", p.Value)
  }
}
```

如果需要频繁的插入和删除元素应该选用链表，如果频繁的获取元素应该用动态数组。


### 栈

这里的`栈`是一种数据结构，和内存中的栈空间完全不是一个东西。

栈这种数据结构的特点是`后进先出`，只能在一端进行操作，最后添加进来的元素最先出去，添加元素称为入栈（push），获取元素称为出栈（pop）。

栈这种数据结构其实可以用上面的动态数组或链表来实现都可以。


### 队列

`队列`只能在头尾两端进行操作。

只能从对尾添加元素，只能从对头移除元素。往队尾添加元素叫做入队(EnQueue)，从队头移除元素叫做出队(DeQueue)，

队列优先使用双向链表来实现，因为队列主要是在对头和对尾进行操作。


### 二叉搜索树

想象一个需求，在n个整数中如何查找某个整数是否存在。

这时如果利用我们上面说的动态数组，链表，栈，队列这些数据结构都是不太好实现的，如果用动态数组的话，需要遍历数组中的所有元素，一个个来比较。链表也是一样。时间复杂度都是 `O(n)` 。

那么有没有更好的方案呢？

答案是有的，就是使用二叉搜索树。二叉搜索树的查找，添加，删除的时间复杂度都是 `O(logn)` 。

`二叉搜索树`是一种树形的数据结构（动态数组，链表都是线形的），二叉搜索树中的元素都是可比较的。顾名思义是两个叉的，每个节点都有 `left` 和 `right` 两个指针，比她小的就存左边，大的就存右边。

`二叉搜索树` 的节点的结构是：

```
type treeNode struct {
  element interface{}
  left *treeNode
  right *treeNode
}
```

添加一个元素的时候，会先和根节点比较，比根节点小，就往左走，反之往右走，直到比较的那个节点没有子节点了，就添加在那个节点的左边或右边。搜索一个元素的时候，也是和根节点比较，比他小就往左边搜索，比他大就往右边搜索。也就是说，添加，删除，搜索的时候，每经过一次比较，就可以排除一般的元素，所以性能是非常好的。


### 平衡二叉搜索树（AVL树）

二叉搜索树在一些特殊情况下会`退化成链表`，这样的话再做添加搜索删除的操作，时间复杂度就很高了。所以我们需要一种机制能防止二叉搜索树退化成链表。

这种机制叫做`平衡`。

平衡二叉搜索树使用`平衡因子`（balance factor）来实现平衡。让树中所有节点的`左右子树的高度差的绝对值不超过1`。如果超过1了，就说明这个节点不平衡了，需要做一些操作来使这个节点重新恢复平衡。

这里涉及到两个概念，`节点的高度`和`树的高度`。节点的高度等于当前节点到最远叶子节点的路径上饿节点总数。树的高度取所有节点高度中的最大值。

既然上面说左右子树的高度差超过1了就不平衡了，那么怎么恢复平衡呢？

就是通过`旋转`。旋转分为`左旋转`和`右旋转`。旋转是什么意思呢？

我们直接来看动画，图片中节点的左上角有个数字，表示那个节点的高度，在加入7这个节点后，节点5的左子树高度是0，右子树高度是2，相差为2，就是平衡因子为2，表示5这个节点不平衡了，需要对5这个失衡的节点进行左旋转。

<div align="center"><img width="300px" src="./2020.05.12/leftrotate.gif"/></div>

对失衡的节点进行旋转很好理解，但是图中这种情况为什么是左旋转？这就要看比较高的子树是在失衡节点的哪一边，图中是失衡节点5的右子树太高了，所以要进行左旋转。同理，如果是左子树太高了，就进行右旋转。

以下是右旋转的例子：

<div align="center"><img width="300px" src="./2020.05.12/rightrotate.gif"/></div>


通过旋转那个失衡节点，使那个失衡的节点往下走，让他比较高的那个子树往上走，然后这个失衡的节点成为子节点的子节点，来达到平衡。

### 红黑树

红黑树也是一种平衡树，但是平衡的方法和AVL树不一样，红黑树只遵循5条性质，只要遵循了这5条性质，这颗红黑树自然就平衡了。红黑树上的节点不是红色就是黑色，这个颜色不代表任何东西，只是单纯的为了满足他的性质。这5条性质是：

1. 红黑树中的节点不是红色就是黑色。
2. 根节点必须是黑色。
3. 叶子节点都是黑色。
4. 红色节点的子节点都是黑色。
5. 从任意节点到叶子节点的所有路径都包含相同数目的黑色节点。

只要一棵树满足了这5个条件，这棵树就很神奇的平衡了。注意：红黑树不是靠平衡因子来平衡的，所以在红黑树中没有平衡因子这个概念。