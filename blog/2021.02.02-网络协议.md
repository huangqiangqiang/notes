# 网络协议

## 5层网络互联模型

```
应用层
传输层
网络层
数据链路层
物理层
```

应用层：这个应用层的意思应该是划分应用场景，比如 HTTP，FTP，SMTP，DNS，XMPP 等。HTTP 应用在请求数据方面，FTP 负责文件传输，DNS 负责域名解析，SMTP 负责邮件发送。针对不同的领域设计出不同的协议。就是应用层。

传输层：传输层就两种协议，TCP 和 UDP，负责数据的传输。TCP 的话还要负责可靠传输，保证不丢数据包。

网络层：网络层负责

数据链路层：
## DHCP

DHCP（Dynamic Host Configuration Protocol），译为动态主机配置协议。作用是给客户端分配 IP。

DHCP 协议基于 UDP 协议，客户端是 68 端口，服务器是 67 端口。

家里的路由器就可以充当 DHCP 服务器，DHCP 会从 IP 地址池中选出 IP 分配给客户端。注意，这里的 IP 是租给客户端的，是有时间限制的。时间到了客户端和 DHCP 服务器之间会有续约的动作。

## DNS

什么是 DNS 就不用多说了吧，就是一个域名解析系统，把我们平常在浏览器中输入的域名解析成 IP，才能访问对应的网站。

那么为什么不能直接输入域名，直接定位到网站呢？这是因为 IP 有固定的长度，而域名可长可短，在网络模型中的网络层，只有固定的四个字节是放目标固定 IP 的，如果换成域名了，这个地方就不知道要留多少字节给域名了。

但是单纯的 IP 很难记忆，所以又延伸出了域名系统，专门有很多的 DNS 服务器来把域名转换成 IP。

下面详细说说 DNS 解析的流程，当我们浏览器中输入域名的时候，会先访问到 ISP（网络服务提供商，比如移动，电信）的 DNS 服务器，一般 ISP 会有 DNS 缓存，如果 ISP 没有，则直接访问到根 DNS 服务器，而在根域名服务器，只保存其下一级域名服务器，下一级服务器主要有 com，net，org 等等。比如我们访问了 baidu.com，这是个二级域名，com 本身才是一级域名，根域名会判断这个域名的一级域名是 com，然后转发到 com 一级域名服务器，一级域名服务器又会解析出二级域名是 baidu，然后转发到 baidu 相关的二级域名服务器，只有 baidu 相关的二级域名服务器才记录着 baidu.com 对应的 IP 地址。

## ICMP

ICMP 全称为 Internet Control Message Protocol（互联网控制消息协议）。我们平常接触到的最多的就是 ping 命令，我们平时都使用 ping 命令测试两台主机之间网络通不通，其实 ping 命令底层就是使用的 ICMP 协议。

ICMP 通常用于返回错误信息。比如我们使用 ping 命令测试两台主机之间网络通不通，不通的话会返回错误信息。

ICMP 协议属于网络层协议，是在网络层直接生成数据包并传递给数据链路层。有些时候我们科学上网了，在终端中使用 curl 命令可以访问 google.com，但是使用 ping 命令却不通，是因为 ICMP 协议处在更底层。

## WebSocket

WebSocket 是一套 HTML5 协议，不要和 socket 搞混了，socket 是一套网络编程的 API。他们之间没什么关系。WebSocket 是为了填补 HTTP 的一些缺陷而设计的，因为 HTTP 只能是 请求 - 响应 模式，一次请求一次响应，不能实现服务端主动推送消息给客户端。早期客户端为了模拟推送，只能使用轮询。

WebSocket 的协议是 ws:// 或 wss:// ，对应 http 和 https。端口和 http 一样，使用的是 80 端口和 443 端口。

WebSocket 需要先建立连接，但是这个连接和 TCP 的3次握手建立连接不是一个意思，WebSocket 是使用 http 建立连接的，也叫握手。相当于是先建立一个 http 连接，再升级成为 WebSocket 连接。WebSocket 也是属于应用层的协议，和 HTTP 是平级的。

WebSocket 使用 HTTP 协议建立连接，请求头中会包含
```
Upgrade: websocket
Connection: Upgrade
```
这么两个请求头，表示这是一个 WebSocket 的握手请求。

注意：服务器推送信息，其实还有一种方法：Server-Sent Events，简称 SSE，本质是把服务器的响应伪装成流信息（stream），发送的是一个数据流，这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流。

## RESTful

REST 是一种软件架构设计风格，也可以说是一些规则把，没有对错之分。符合 REST 架构的服务，称为 RESTful 服务。

几个主要的规则是：
1. URL 中使用名词，不使用动词，而且名词建议使用复数。
2. 使用 HTTP 的方法表达动作。
比如 GET 代表查询，POST 代表创建，PUT 代表更新，DELETE 代表删除。
3. 一个资源连接到其他资源，使用子资源的形式。
比如`GET /users/6/cars/88`
4. API 版本化。
5. 使用 JSON 返回格式。
6. 发生错误时，不要使用 200 状态码。
比如参数错误返回 400，用户未登录返回 401。

REST 只是一套设计风格，不同的人有不同的实践，可能会有所差异。上面是几个主要的点。

## 跨域

为了安全，浏览器一般都有 同源策略，不能在浏览器中使用异步请求的方式访问跨域的地址，这里的跨域指的是 `协议，host，端口` 三者只要有一个不同，就称为跨域。

跨域的解决方式就不说了，网上一搜一大堆，原理就是设置一些跨域相关的响应头来允许跨域访问。

一些细节：像 HTML 里面一些标签，引用的 css，js 等是不受同源策略的影响的。

## 3次握手

建立 TCP 连接需要 3 次握手，下面讲讲为什么需要 3 次，而不是 2 次或 4 次。

个人感觉目前网上那个打电话的比喻不太合适。

## 4次挥手

## TCP 的可靠传输

是靠ack完成的，我们发的http请求会被拆分为多个tcp包，每个包会携带seq，而且seq是自增的，三次握手的过程中会交换双方的初始seq，服务端每收到一个自增的包就会回复客户端ack确认，如果客户端没收到ack，就会超时重发。

## HTTP/1.1

在 HTTP 1.0 版本的时候，客户端和服务器的交互方式比较单一，只有建立连接，客户端发送数据，服务器返回响应，断开连接。如果有多个请求只能是创建多个连接。

HTTP 的请求报文格式：

```
起始行->       GET /foo/bar HTTP/1.1
请求头->       Accept: *
              Host: www.test.com
请求体->       
```

HTTP 的响应报文格式：
```
起始行->       HTTP/1.1 200 OK
响应头->       Content-Type: application/json
响应体->       {status:ok}
```

新特性：
在 HTTP 1.1 版本，多个请求可以共用一个连接。

不足：
1. 一个连接在同一时刻只能处理一个请求，只有当前请求的响应回来了，才能发送下一个请求，这些请求之间可以省去 TCP 的握手过程。如果有多个并发的请求，还是需要创建多个连接。
2. 还有一个比较麻烦的限制是，针对同一个域名，同一时间最多只能并发 6 个连接。
3. 在同一个连接的多次请求中，请求头会被重复传输。

针对第三点缺陷，在 HTTP/1.1 的情况下只能采用一些曲线救国的方式，比如减少图片，css，js的请求数量，域名分片等。

## HTTP/2

HTTP/2 在底层传输做了很多改进和优化，HTTP/2 在语法上完全兼容 HTTP/1.1。所以想要支持 HTTP/2，只需修改配置，不需要修改代码。

HTTP/2 针对了 HTTP/1.1 的以上 3 点缺陷做了改进。

HTTP/1.1 中，传输的数据都是文本格式的，在 HTTP/2 的版本中，采用二进制格式传输，把请求头和请求体封装为帧。这些帧会被打散。后续发送的请求和响应都是由一系列的帧组成的。可能多个不同的请求的帧会被混合发给服务端。帧是 HTTP/2 通信的最小单位，每个帧都包含帧头，服务端或客户端可以通过帧头来判断出当前帧所属哪个请求。HTTP/2 的共用连接能真正实现并发请求。

HTTP/2 还有一个头部压缩的特性，客户端和服务器会缓存之前的请求数据，把每个请求头中的 key/value 数据弄成一个索引表，如果后面的请求中请求头有相同的 key/value 值的，只需要发一个索引过去就行了。

但是 HTTP/2 还是有一些问题，一个叫队头阻塞，一个叫握手延迟。

队头阻塞：因为 HTTP/2 走的是 TCP 协议，虽然 HTTP/2 内部会把多个请求打散成为帧发出去，但是 TCP 是不知道的，比如现在并发A，B，C三个请求，在 HTTP/2 中，这三个请求会被打散成帧发送，如果在 TCP 层传输的过程中第一个包丢掉了，如果第一个包里面的内容恰好都是请求A的，也就是说请求B，C的内容没有丢失，也是不能立即执行请求B，C的，需要等到第一个包接收到才行。

握手延迟：顾名思义，就是握手阶段会花费一些时间。

上面的两点说是 HTTP/2 的缺陷，还不如说是 TCP 的缺陷。因为 TCP 的机制就是这样的。我们接下来看 HTTP/3 怎么改进。

## HTTP/3

HTTP/3 也针对 HTTP/2 的缺陷做了改进。我们上面分析到 HTTP/2 的缺陷其实是 TCP 的缺陷。所以 HTTP/3 弃用了 TCP，使用 UDP。然后在应用层，也就是 HTTP 层加入 QUIC 保证可靠传输。HTTP 语法没变，对开发者没影响。

不过 HTTP/3 的缺陷目前也是有的，就是比较耗费 CPU 的性能，因为很多硬件有专门对 TCP 做过优化， 