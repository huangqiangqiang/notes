快过年了，也没什么心思工作了，就去看了一些算法...

# 冒泡排序

> 每次比较两个相邻的元素，如果他们的顺序错误就交换他们的位置。

```
# 从大到小排序

func main() {
	arr := []int{12, 34, 85, 18, 56}
	for i := 0; i < len(arr)-1; i++ {
		for j := 0; j < len(arr)-1; j++ {
			if arr[j] < arr[j+1] {
				t := arr[j]
				arr[j] = arr[j+1]
				arr[j+1] = t
			}
		}
	}
	fmt.Println(arr)
}

```

冒泡排序的核心部分是一个双重for循环，时间复杂度是O(N^2)，这是一个很高的时间复杂度，不得已不要使用。

冒泡排序的外层循环执行一次称为一趟，一趟只能让一个数归位，所以需要 len(arr) - 1 次循环。

# 快速排序

```

```